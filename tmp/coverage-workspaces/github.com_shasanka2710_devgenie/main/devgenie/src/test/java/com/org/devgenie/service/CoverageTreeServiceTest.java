package com.org.devgenie.service;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Generated test class for CoverageTreeService
 * Auto-generated by DevGenie Coverage Improvement System
 */
class CoverageTreeServiceTest {

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    @DisplayName("Tests that fetchAndStoreComponentsWithCoverage correctly fetches nodes, filters for 'src/main' paths, and saves only these filtered nodes to the repository. It simulates the SonarQube API responses for pagination.")
        void fetchAndStoreComponentsWithCoverage_FiltersAndSavesMainComponents() {
        // Arrange
        com.org.devgenie.mongo.CoverageComponentRepository repository = Mockito.mock(com.org.devgenie.mongo.CoverageComponentRepository.class);
        org.springframework.web.client.RestTemplate restTemplate = Mockito.mock(org.springframework.web.client.RestTemplate.class);
        com.org.devgenie.service.CoverageTreeService service = new com.org.devgenie.service.CoverageTreeService(repository);

        // Set @Value fields and autowired RestTemplate using reflection
        try {
            java.lang.reflect.Field sonarUrlField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("sonarUrl");
            sonarUrlField.setAccessible(true);
            sonarUrlField.set(service, "http://mock-sonar.com");
            java.lang.reflect.Field sonarUsernameField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("sonarUsername");
            sonarUsernameField.setAccessible(true);
            sonarUsernameField.set(service, "user");
            java.lang.reflect.Field sonarPasswordField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("sonarPassword");
            sonarPasswordField.setAccessible(true);
            sonarPasswordField.set(service, "pass");
            java.lang.reflect.Field restTemplateField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("restTemplate");
            restTemplateField.setAccessible(true);
            restTemplateField.set(service, restTemplate);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            org.junit.jupiter.api.Assertions.fail("Failed to set private fields via reflection: " + e.getMessage());
        }

        // Prepare mock data for SonarQube API responses
        // Page 1: Contains one src/main and one src/test component
        java.util.Map<String, Object> page1Response = new java.util.HashMap<>();
        page1Response.put("paging", java.util.Map.of("total", 3, "p", 1, "ps", 50));
        java.util.List<java.util.Map<String, Object>> componentsPage1 = new java.util.ArrayList<>();
        componentsPage1.add(java.util.Map.of("key", "proj:src/main/App.java", "path", "src/main/App.java", "qualifier", "FIL", "measures", java.util.List.of(java.util.Map.of("metric", "coverage", "value", "80.0"))));
        componentsPage1.add(java.util.Map.of("key", "proj:src/test/Test.java", "path", "src/test/Test.java", "qualifier", "FIL", "measures", java.util.List.of(java.util.Map.of("metric", "coverage", "value", "90.0"))));
        page1Response.put("components", componentsPage1);

        // Page 2: Contains one src/main component
        java.util.Map<String, Object> page2Response = new java.util.HashMap<>();
        java.util.List<java.util.Map<String, Object>> componentsPage2 = new java.util.ArrayList<>();
        componentsPage2.add(java.util.Map.of("key", "proj:src/main/Service.java", "path", "src/main/Service.java", "qualifier", "FIL", "measures", java.util.List.of(java.util.Map.of("metric", "coverage", "value", "75.0"))));
        page2Response.put("components", componentsPage2);

        // Page 3: Empty to signal end of pagination
        java.util.Map<String, Object> page3Response = new java.util.HashMap<>();
        page3Response.put("components", java.util.Collections.emptyList());

        // Configure mock RestTemplate to return these responses sequentially
        Mockito.when(restTemplate.exchange(
                Mockito.anyString(),
                Mockito.eq(org.springframework.http.HttpMethod.GET),
                Mockito.any(org.springframework.http.HttpEntity.class),
                Mockito.eq(java.util.Map.class)))
                .thenReturn(org.springframework.http.ResponseEntity.ok(page1Response))
                .thenReturn(org.springframework.http.ResponseEntity.ok(page2Response))
                .thenReturn(org.springframework.http.ResponseEntity.ok(page3Response));

        // Expected nodes after filtering to be saved and returned
        com.org.devgenie.model.CoverageComponentNode expectedNode1 = new com.org.devgenie.model.CoverageComponentNode();
        expectedNode1.setKey("proj:src/main/App.java");
        expectedNode1.setPath("src/main/App.java");
        expectedNode1.setType("FIL");
        expectedNode1.setMetricsMap(java.util.Map.of("coverage", 80.0));

        com.org.devgenie.model.CoverageComponentNode expectedNode2 = new com.org.devgenie.model.CoverageComponentNode();
        expectedNode2.setKey("proj:src/main/Service.java");
        expectedNode2.setPath("src/main/Service.java");
        expectedNode2.setType("FIL");
        expectedNode2.setMetricsMap(java.util.Map.of("coverage", 75.0));

        java.util.List<com.org.devgenie.model.CoverageComponentNode> expectedSavedNodes = java.util.List.of(expectedNode1, expectedNode2);

        // Act
        java.util.List<com.org.devgenie.model.CoverageComponentNode> actualMainNodes = service.fetchAndStoreComponentsWithCoverage("myProject");

        // Assert
        // Verify saveAll was called with the correct filtered list
        Mockito.verify(repository, Mockito.times(1)).saveAll(Mockito.argThat(argument -> {
            if (argument.size() != expectedSavedNodes.size()) return false;
            for (int i = 0; i < argument.size(); i++) {
                // Basic comparison for demonstration; a full equals/hashCode in CoverageComponentNode would be ideal
                if (!argument.get(i).getKey().equals(expectedSavedNodes.get(i).getKey()) ||
                    !argument.get(i).getPath().equals(expectedSavedNodes.get(i).getPath()) ||
                    !argument.get(i).getType().equals(expectedSavedNodes.get(i).getType()) ||
                    !argument.get(i).getMetricsMap().equals(expectedSavedNodes.get(i).getMetricsMap())) {
                    return false;
                }
            }
            return true;
        }));

        // Verify the returned list is correct
        org.junit.jupiter.api.Assertions.assertEquals(expectedSavedNodes.size(), actualMainNodes.size());
        org.junit.jupiter.api.Assertions.assertEquals(expectedSavedNodes.get(0).getPath(), actualMainNodes.get(0).getPath());
        org.junit.jupiter.api.Assertions.assertEquals(expectedSavedNodes.get(1).getPath(), actualMainNodes.get(1).getPath());
    }

    @Test
    @DisplayName("Tests the fetchCoverageNodes method's ability to handle pagination and correctly parse various data types from the SonarQube API response, including metrics. It verifies the number of API calls and the content of the parsed nodes.")
        void fetchCoverageNodes_HandlesPaginationAndParsesData() {
        // Arrange
        com.org.devgenie.mongo.CoverageComponentRepository repository = Mockito.mock(com.org.devgenie.mongo.CoverageComponentRepository.class);
        org.springframework.web.client.RestTemplate restTemplate = Mockito.mock(org.springframework.web.client.RestTemplate.class);
        com.org.devgenie.service.CoverageTreeService service = new com.org.devgenie.service.CoverageTreeService(repository);

        // Set @Value fields and autowired RestTemplate using reflection
        try {
            java.lang.reflect.Field sonarUrlField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("sonarUrl");
            sonarUrlField.setAccessible(true);
            sonarUrlField.set(service, "http://mock-sonar.com");
            java.lang.reflect.Field sonarUsernameField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("sonarUsername");
            sonarUsernameField.setAccessible(true);
            sonarUsernameField.set(service, "user");
            java.lang.reflect.Field sonarPasswordField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("sonarPassword");
            sonarPasswordField.setAccessible(true);
            sonarPasswordField.set(service, "pass");
            java.lang.reflect.Field restTemplateField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("restTemplate");
            restTemplateField.setAccessible(true);
            restTemplateField.set(service, restTemplate);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            org.junit.jupiter.api.Assertions.fail("Failed to set private fields via reflection: " + e.getMessage());
        }

        // Mock SonarQube API responses for two pages with different metrics and qualifiers
        java.util.Map<String, Object> page1Response = new java.util.HashMap<>();
        page1Response.put("paging", java.util.Map.of("total", 3, "p", 1, "ps", 50));
        java.util.List<java.util.Map<String, Object>> componentsPage1 = new java.util.ArrayList<>();
        componentsPage1.add(java.util.Map.of(
                "key", "proj:file1", "path", "src/main/file1.java", "qualifier", "FIL",
                "measures", java.util.List.of(
                        java.util.Map.of("metric", "coverage", "value", "85.5"),
                        java.util.Map.of("metric", "lines_to_cover", "value", "100"))
        ));
        page1Response.put("components", componentsPage1);

        java.util.Map<String, Object> page2Response = new java.util.HashMap<>();
        java.util.List<java.util.Map<String, Object>> componentsPage2 = new java.util.ArrayList<>();
        componentsPage2.add(java.util.Map.of(
                "key", "proj:dir1", "path", "src/main/dir1", "qualifier", "DIR",
                "measures", java.util.List.of(
                        java.util.Map.of("metric", "branch_coverage", "value", "70.0"),
                        java.util.Map.of("metric", "uncovered_lines", "value", "10"))
        ));
        page2Response.put("components", componentsPage2);

        java.util.Map<String, Object> page3Response = new java.util.HashMap<>(); // Empty page to simulate end of results
        page3Response.put("components", java.util.Collections.emptyList());

        // Configure mock RestTemplate to return these responses sequentially for different page numbers
        Mockito.when(restTemplate.exchange(
                Mockito.argThat(uri -> uri.contains("p=1")),
                Mockito.eq(org.springframework.http.HttpMethod.GET),
                Mockito.any(org.springframework.http.HttpEntity.class),
                Mockito.eq(java.util.Map.class)))
                .thenReturn(org.springframework.http.ResponseEntity.ok(page1Response));

        Mockito.when(restTemplate.exchange(
                Mockito.argThat(uri -> uri.contains("p=2")),
                Mockito.eq(org.springframework.http.HttpMethod.GET),
                Mockito.any(org.springframework.http.HttpEntity.class),
                Mockito.eq(java.util.Map.class)))
                .thenReturn(org.springframework.http.ResponseEntity.ok(page2Response));

        Mockito.when(restTemplate.exchange(
                Mockito.argThat(uri -> uri.contains("p=3")),
                Mockito.eq(org.springframework.http.HttpMethod.GET),
                Mockito.any(org.springframework.http.HttpEntity.class),
                Mockito.eq(java.util.Map.class)))
                .thenReturn(org.springframework.http.ResponseEntity.ok(page3Response));

        // Act
        // Calling fetchAndStoreComponentsWithCoverage to trigger the private fetchCoverageNodes method
        java.util.List<com.org.devgenie.model.CoverageComponentNode> actualNodes = service.fetchAndStoreComponentsWithCoverage("testProject");

        // Assert
        // Verify RestTemplate was called for all expected pages
        Mockito.verify(restTemplate, Mockito.times(3)).exchange(
                Mockito.anyString(),
                Mockito.eq(org.springframework.http.HttpMethod.GET),
                Mockito.any(org.springframework.http.HttpEntity.class),
                Mockito.eq(java.util.Map.class));

        // Verify that all 'src/main' nodes from all pages are correctly parsed and returned
        org.junit.jupiter.api.Assertions.assertEquals(2, actualNodes.size()); // Only src/main nodes are returned by fetchAndStore

        com.org.devgenie.model.CoverageComponentNode node1 = actualNodes.get(0);
        org.junit.jupiter.api.Assertions.assertEquals("proj:file1", node1.getKey());
        org.junit.jupiter.api.Assertions.assertEquals("src/main/file1.java", node1.getPath());
        org.junit.jupiter.api.Assertions.assertEquals("FIL", node1.getType());
        org.junit.jupiter.api.Assertions.assertEquals(2, node1.getMetricsMap().size());
        org.junit.jupiter.api.Assertions.assertEquals(85.5, node1.getMetricsMap().get("coverage"), 0.001);
        org.junit.jupiter.api.Assertions.assertEquals(100.0, node1.getMetricsMap().get("lines_to_cover"), 0.001);

        com.org.devgenie.model.CoverageComponentNode node2 = actualNodes.get(1);
        org.junit.jupiter.api.Assertions.assertEquals("proj:dir1", node2.getKey());
        org.junit.jupiter.api.Assertions.assertEquals("src/main/dir1", node2.getPath());
        org.junit.jupiter.api.Assertions.assertEquals("DIR", node2.getType());
        org.junit.jupiter.api.Assertions.assertEquals(2, node2.getMetricsMap().size());
        org.junit.jupiter.api.Assertions.assertEquals(70.0, node2.getMetricsMap().get("branch_coverage"), 0.001);
        org.junit.jupiter.api.Assertions.assertEquals(10.0, node2.getMetricsMap().get("uncovered_lines"), 0.001);
    }

    @Test
    @DisplayName("Tests fetchCoverageNodes method's resilience to API errors (RestClientException), null responses, empty component lists, and invalid metric values (NumberFormatException).")
        void fetchCoverageNodes_HandlesApiErrorsAndEdgeCases() {
        // Arrange
        com.org.devgenie.mongo.CoverageComponentRepository repository = Mockito.mock(com.org.devgenie.mongo.CoverageComponentRepository.class);
        org.springframework.web.client.RestTemplate restTemplate = Mockito.mock(org.springframework.web.client.RestTemplate.class);
        com.org.devgenie.service.CoverageTreeService service = new com.org.devgenie.service.CoverageTreeService(repository);

        // Set @Value fields and autowired RestTemplate using reflection
        try {
            java.lang.reflect.Field sonarUrlField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("sonarUrl");
            sonarUrlField.setAccessible(true);
            sonarUrlField.set(service, "http://mock-sonar.com");
            java.lang.reflect.Field sonarUsernameField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("sonarUsername");
            sonarUsernameField.setAccessible(true);
            sonarUsernameField.set(service, "user");
            java.lang.reflect.Field sonarPasswordField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("sonarPassword");
            sonarPasswordField.setAccessible(true);
            sonarPasswordField.set(service, "pass");
            java.lang.reflect.Field restTemplateField = com.org.devgenie.service.CoverageTreeService.class.getDeclaredField("restTemplate");
            restTemplateField.setAccessible(true);
            restTemplateField.set(service, restTemplate);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            org.junit.jupiter.api.Assertions.fail("Failed to set private fields via reflection: " + e.getMessage());
        }

        // --- Scenario 1: RestClientException during API call ---
        // Mock behavior to throw an exception on the first call
        Mockito.when(restTemplate.exchange(
                Mockito.anyString(),
                Mockito.eq(org.springframework.http.HttpMethod.GET),
                Mockito.any(org.springframework.http.HttpEntity.class),
                Mockito.eq(java.util.Map.class)))
                .thenThrow(new org.springframework.web.client.RestClientException("Simulated network error"));

        // Act
        java.util.List<com.org.devgenie.model.CoverageComponentNode> nodesOnError = service.fetchAndStoreComponentsWithCoverage("errorProject");

        // Assert
        org.junit.jupiter.api.Assertions.assertTrue(nodesOnError.isEmpty(), "Should return an empty list on RestClientException");
        Mockito.verify(restTemplate, Mockito.times(1)).exchange(Mockito.anyString(), Mockito.any(), Mockito.any(), Mockito.any());
        Mockito.reset(restTemplate); // Reset mock for next scenario

        // --- Scenario 2: Null response body ---
        Mockito.when(restTemplate.exchange(
                Mockito.anyString(),
                Mockito.eq(org.springframework.http.HttpMethod.GET),
                Mockito.any(org.springframework.http.HttpEntity.class),
                Mockito.eq(java.util.Map.class)))
                .thenReturn(org.springframework.http.ResponseEntity.ok(null)); // Simulate null body

        // Act
        java.util.List<com.org.devgenie.model.CoverageComponentNode> nodesOnNullBody = service.fetchAndStoreComponentsWithCoverage("nullBodyProject");

        // Assert
        org.junit.jupiter.api.Assertions.assertTrue(nodesOnNullBody.isEmpty(), "Should return an empty list on null response body");
        Mockito.verify(restTemplate, Mockito.times(1)).exchange(Mockito.anyString(), Mockito.any(), Mockito.any(), Mockito.any());
        Mockito.reset(restTemplate); // Reset mock for next scenario

        // --- Scenario 3: Empty components list on first page ---
        java.util.Map<String, Object> emptyComponentsResponse = new java.util.HashMap<>();
        emptyComponentsResponse.put("components", java.util.Collections.emptyList());
        emptyComponentsResponse.put("paging", java.util.Map.of("total", 0, "p", 1, "ps", 50));

        Mockito.when(restTemplate.exchange(
                Mockito.anyString(),
                Mockito.eq(org.springframework.http.HttpMethod.GET),
                Mockito.any(org.springframework.http.HttpEntity.class),
                Mockito.eq(java.util.Map.class)))
                .thenReturn(org.springframework.http.ResponseEntity.ok(emptyComponentsResponse));

        // Act
        java.util.List<com.org.devgenie.model.CoverageComponentNode> nodesOnEmptyComponents = service.fetchAndStoreComponentsWithCoverage("emptyComponentsProject");

        // Assert
        org.junit.jupiter.api.Assertions.assertTrue(nodesOnEmptyComponents.isEmpty(), "Should return an empty list if components list is empty on first page");
        Mockito.verify(restTemplate, Mockito.times(1)).exchange(Mockito.anyString(), Mockito.any(), Mockito.any(), Mockito.any());
        Mockito.reset(restTemplate); // Reset mock for next scenario

        // --- Scenario 4: NumberFormatException in metric parsing ---
        java.util.Map<String, Object> invalidMetricResponse = new java.util.HashMap<>();
        invalidMetricResponse.put("paging", java.util.Map.of("total", 1, "p", 1, "ps", 50));
        java.util.List<java.util.Map<String, Object>> componentsWithInvalidMetric = new java.util.ArrayList<>();
        componentsWithInvalidMetric.add(java.util.Map.of(
                "key", "proj:invalidMetric", "path", "src/main/Invalid.java", "qualifier", "FIL",
                "measures", java.util.List.of(
                        java.util.Map.of("metric", "coverage", "value", "80.0"),
                        java.util.Map.of("metric", "line_coverage", "value", "NOT_A_NUMBER")) // Invalid value
        ));
        invalidMetricResponse.put("components", componentsWithInvalidMetric);

        Mockito.when(restTemplate.exchange(
                Mockito.anyString(),
                Mockito.eq(org.springframework.http.HttpMethod.GET),
                Mockito.any(org.springframework.http.HttpEntity.class),
                Mockito.eq(java.util.Map.class)))
                .thenReturn(org.springframework.http.ResponseEntity.ok(invalidMetricResponse));

        // Act
        java.util.List<com.org.devgenie.model.CoverageComponentNode> nodesWithInvalidMetric = service.fetchAndStoreComponentsWithCoverage("invalidMetricProject");

        // Assert
        org.junit.jupiter.api.Assertions.assertEquals(1, nodesWithInvalidMetric.size(), "Should return one node despite invalid metric");
        com.org.devgenie.model.CoverageComponentNode node = nodesWithInvalidMetric.get(0);
        org.junit.jupiter.api.Assertions.assertEquals("proj:invalidMetric", node.getKey());
        org.junit.jupiter.api.Assertions.assertEquals("src/main/Invalid.java", node.getPath());
        // Verify that the valid metric is present, and the invalid one is not (due to parsing error)
        org.junit.jupiter.api.Assertions.assertTrue(node.getMetricsMap().containsKey("coverage"));
        org.junit.jupiter.api.Assertions.assertEquals(80.0, node.getMetricsMap().get("coverage"), 0.001);
        org.junit.jupiter.api.Assertions.assertFalse(node.getMetricsMap().containsKey("line_coverage"), "Invalid metric should not be in the map");
    }

}
