package com.org.devgenie.controller.coverage;

import com.org.devgenie.service.coverage.AsyncCoverageProcessor;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

/**
 * Unit tests for {@link CoverageWebSocketController}.
 * This class focuses on testing the event listener methods to ensure they correctly process events
 * and log the appropriate messages.
 */
@ExtendWith(MockitoExtension.class)
class CoverageWebSocketControllerTest {

    private CoverageWebSocketController coverageWebSocketController;

    // Mock Logger to capture log messages
    @Mock
    private Logger mockLogger;

    private MockedStatic<LoggerFactory> mockedLoggerFactory;

    @BeforeEach
    void setUp() {
        // Mock the static LoggerFactory to return our mockLogger
        // This allows us to verify interactions with the 'log' field generated by Lombok's @Slf4j
        mockedLoggerFactory = mockStatic(LoggerFactory.class);
        mockedLoggerFactory.when(() -> LoggerFactory.getLogger(any(Class.class)))
                            .thenReturn(mockLogger);

        coverageWebSocketController = new CoverageWebSocketController();
    }

    @org.junit.jupiter.api.AfterEach
    void tearDown() {
        // Close the mocked static LoggerFactory to prevent interference with other tests
        mockedLoggerFactory.close();
    }

    /**
     * Tests the handleCoverageCompleted method to ensure it correctly processes a CoverageCompletedEvent
     * and logs the appropriate success message.
     */
    @Test
    void testHandleCoverageCompleted() {
        // Arrange
        String sessionId = "testSession123";
        AsyncCoverageProcessor.CoverageCompletedEvent event = new AsyncCoverageProcessor.CoverageCompletedEvent(this, sessionId);

        // Act
        coverageWebSocketController.handleCoverageCompleted(event);

        // Assert
        // Verify that log.info was called with the correct message
        ArgumentCaptor<String> logMessageCaptor = ArgumentCaptor.forClass(String.class);
        verify(mockLogger).info(logMessageCaptor.capture(), eq(sessionId));

        String expectedLogMessagePrefix = "Coverage completion event received for session: {} (handled by native WebSocket)";
        assertEquals(expectedLogMessagePrefix, logMessageCaptor.getValue());
    }

    /**
     * Tests the handleCoverageFailed method to ensure it correctly processes a CoverageFailedEvent
     * and logs the appropriate failure message.
     */
    @Test
    void testHandleCoverageFailed() {
        // Arrange
        String sessionId = "failedSession456";
        AsyncCoverageProcessor.CoverageFailedEvent event = new AsyncCoverageProcessor.CoverageFailedEvent(this, sessionId);

        // Act
        coverageWebSocketController.handleCoverageFailed(event);

        // Assert
        // Verify that log.info was called with the correct message
        ArgumentCaptor<String> logMessageCaptor = ArgumentCaptor.forClass(String.class);
        verify(mockLogger).info(logMessageCaptor.capture(), eq(sessionId));

        String expectedLogMessagePrefix = "Coverage failure event received for session: {} (handled by native WebSocket)";
        assertEquals(expectedLogMessagePrefix, logMessageCaptor.getValue());
    }
}